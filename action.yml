name: 'Wait for ArgoCD Sync'
description: 'Wait for ArgoCD-managed workloads to sync and become ready by monitoring resources directly in the target cluster'
author: 'Skyhook'

branding:
  icon: 'refresh-cw'
  color: 'orange'

inputs:
  app_name:
    description: 'Application name (used as label selector: app.kubernetes.io/name=<app_name>)'
    required: true
  namespace:
    description: 'Target namespace where workloads are deployed'
    required: true
  selector:
    description: 'Custom label selector (overrides app_name-based selector)'
    required: false
    default: ''
  expected_version:
    description: 'Expected app.kubernetes.io/version label value (e.g., main_2025-12-10_00)'
    required: false
    default: ''
  expected_deployment_id:
    description: 'Expected deployment-id annotation value (e.g., github.run_id)'
    required: false
    default: ''
  timeout:
    description: 'Total timeout for waiting (e.g., 300s, 5m, 10m)'
    required: false
    default: '300s'
  fallback_timeout:
    description: 'Time to wait for changes before checking if already synced (e.g., 180s, 3m). Only used when no expected values provided.'
    required: false
    default: '180s'
  workload_types:
    description: 'Comma-separated workload types to wait for (deployment,statefulset,daemonset)'
    required: false
    default: 'deployment,statefulset,daemonset'

outputs:
  workloads_found:
    description: 'Number of workloads found matching selector'
    value: ${{ steps.wait.outputs.workloads_found }}
  workloads_ready:
    description: 'Number of workloads that became ready'
    value: ${{ steps.wait.outputs.workloads_ready }}
  version_matched:
    description: 'Whether expected version was found (true/false/skipped)'
    value: ${{ steps.wait.outputs.version_matched }}
  deployment_id_matched:
    description: 'Whether expected deployment-id was found (true/false/skipped)'
    value: ${{ steps.wait.outputs.deployment_id_matched }}
  sync_detection_method:
    description: 'How sync was detected (expected_match, change_detected, already_synced)'
    value: ${{ steps.wait.outputs.sync_detection_method }}
  status:
    description: 'Final status (Ready, Timeout, Failed)'
    value: ${{ steps.wait.outputs.status }}
  message:
    description: 'Status message'
    value: ${{ steps.wait.outputs.message }}

runs:
  using: 'composite'
  steps:
    - name: Check required tools
      shell: bash
      run: |
        set -euo pipefail
        command -v kubectl >/dev/null 2>&1 || { echo "::error::kubectl not found"; exit 1; }
        command -v jq >/dev/null 2>&1 || { echo "::error::jq not found"; exit 1; }

    - name: Wait for ArgoCD sync
      id: wait
      shell: bash
      run: |
        set -euo pipefail

        APP_NAME='${{ inputs.app_name }}'
        NAMESPACE='${{ inputs.namespace }}'
        CUSTOM_SELECTOR='${{ inputs.selector }}'
        EXPECTED_VERSION='${{ inputs.expected_version }}'
        EXPECTED_DEPLOY_ID='${{ inputs.expected_deployment_id }}'
        TIMEOUT='${{ inputs.timeout }}'
        FALLBACK_TIMEOUT='${{ inputs.fallback_timeout }}'
        WORKLOAD_TYPES='${{ inputs.workload_types }}'

        # Build selector
        if [ -n "$CUSTOM_SELECTOR" ]; then
          SELECTOR="$CUSTOM_SELECTOR"
        else
          SELECTOR="app.kubernetes.io/name=$APP_NAME"
        fi

        echo "ðŸ” Selector: $SELECTOR"
        echo "ðŸ“¦ Namespace: $NAMESPACE"
        echo "â±ï¸  Timeout: $TIMEOUT"
        [ -n "$EXPECTED_VERSION" ] && echo "ðŸ·ï¸  Expected version: $EXPECTED_VERSION"
        [ -n "$EXPECTED_DEPLOY_ID" ] && echo "ðŸ†” Expected deployment-id: $EXPECTED_DEPLOY_ID"

        # Convert timeout to seconds
        parse_timeout() {
          local val="$1"
          if [[ "$val" =~ ^([0-9]+)s$ ]]; then
            echo "${BASH_REMATCH[1]}"
          elif [[ "$val" =~ ^([0-9]+)m$ ]]; then
            echo $((${BASH_REMATCH[1]} * 60))
          elif [[ "$val" =~ ^([0-9]+)h$ ]]; then
            echo $((${BASH_REMATCH[1]} * 3600))
          else
            echo "300"
          fi
        }

        TIMEOUT_SECS=$(parse_timeout "$TIMEOUT")
        FALLBACK_TIMEOUT_SECS=$(parse_timeout "$FALLBACK_TIMEOUT")
        START_TIME=$(date +%s)

        # ============================================================
        # STEP 0: Capture initial state
        # ============================================================
        echo ""
        echo "ðŸ“‹ Step 0: Capturing initial state..."

        declare -A INITIAL_DEPLOY_IDS
        declare -A INITIAL_GENERATIONS
        declare -A INITIAL_VERSIONS
        INITIAL_WORKLOADS_FOUND=0
        HAS_DEPLOY_IDS="false"

        for TYPE in $(echo "$WORKLOAD_TYPES" | tr ',' ' '); do
          RESOURCES=$(kubectl get "$TYPE" -n "$NAMESPACE" -l "$SELECTOR" -o json 2>/dev/null || echo '{"items":[]}')
          COUNT=$(echo "$RESOURCES" | jq '.items | length')

          for i in $(seq 0 $((COUNT - 1))); do
            NAME=$(echo "$RESOURCES" | jq -r ".items[$i].metadata.name")
            DEPLOY_ID=$(echo "$RESOURCES" | jq -r ".items[$i].metadata.annotations[\"deployment-id\"] // \"\"")
            VERSION=$(echo "$RESOURCES" | jq -r ".items[$i].metadata.labels[\"app.kubernetes.io/version\"] // \"\"")
            GENERATION=$(echo "$RESOURCES" | jq -r ".items[$i].metadata.generation // \"0\"")
            KEY="${TYPE}/${NAME}"

            INITIAL_DEPLOY_IDS["$KEY"]="$DEPLOY_ID"
            INITIAL_GENERATIONS["$KEY"]="$GENERATION"
            INITIAL_VERSIONS["$KEY"]="$VERSION"
            INITIAL_WORKLOADS_FOUND=$((INITIAL_WORKLOADS_FOUND + 1))

            [ -n "$DEPLOY_ID" ] && HAS_DEPLOY_IDS="true"
            echo "  $KEY: version=$VERSION, deployment-id=$DEPLOY_ID, generation=$GENERATION"
          done
        done

        if [ $INITIAL_WORKLOADS_FOUND -eq 0 ]; then
          echo "  No workloads found yet (may be created by sync)"
        fi

        # Determine detection strategy
        DETECTION_STRATEGY="fallback"
        if [ -n "$EXPECTED_DEPLOY_ID" ]; then
          DETECTION_STRATEGY="expected_deployment_id"
          echo ""
          echo "ðŸ“Œ Strategy: Wait for deployment-id=$EXPECTED_DEPLOY_ID"
        elif [ -n "$EXPECTED_VERSION" ]; then
          # Check if version already matches
          VERSION_ALREADY_MATCHES="false"
          for KEY in "${!INITIAL_VERSIONS[@]}"; do
            if [ "${INITIAL_VERSIONS[$KEY]}" == "$EXPECTED_VERSION" ]; then
              VERSION_ALREADY_MATCHES="true"
              break
            fi
          done

          if [ "$VERSION_ALREADY_MATCHES" == "true" ]; then
            # Version matches - need to detect change via deployment-id or generation
            if [ "$HAS_DEPLOY_IDS" == "true" ]; then
              DETECTION_STRATEGY="deployment_id_change"
              echo ""
              echo "ðŸ“Œ Strategy: Version already matches, waiting for deployment-id change"
            else
              DETECTION_STRATEGY="generation_change"
              echo ""
              echo "ðŸ“Œ Strategy: Version already matches, waiting for generation change"
            fi
          else
            DETECTION_STRATEGY="expected_version"
            echo ""
            echo "ðŸ“Œ Strategy: Wait for version=$EXPECTED_VERSION"
          fi
        else
          # No expected values - use fallback with change detection
          if [ "$HAS_DEPLOY_IDS" == "true" ]; then
            DETECTION_STRATEGY="deployment_id_change_fallback"
            echo ""
            echo "ðŸ“Œ Strategy: Wait for deployment-id change (fallback after ${FALLBACK_TIMEOUT_SECS}s)"
          else
            DETECTION_STRATEGY="generation_change_fallback"
            echo ""
            echo "ðŸ“Œ Strategy: Wait for generation change (fallback after ${FALLBACK_TIMEOUT_SECS}s)"
          fi
        fi

        # ============================================================
        # STEP 1: Wait for sync indication
        # ============================================================
        echo ""
        echo "â³ Step 1: Waiting for sync..."

        VERSION_MATCHED="skipped"
        DEPLOY_ID_MATCHED="skipped"
        SYNC_DETECTION_METHOD=""
        WORKLOADS_FOUND=0
        MATCHED_WORKLOADS=""
        LAST_LOG_TIME=0
        FALLBACK_CHECK_DONE="false"

        while true; do
          CURRENT_TIME=$(date +%s)
          ELAPSED=$((CURRENT_TIME - START_TIME))

          if [ $ELAPSED -ge $TIMEOUT_SECS ]; then
            echo "::error::Timeout waiting for workloads after ${TIMEOUT_SECS}s"
            echo "workloads_found=$WORKLOADS_FOUND" >> $GITHUB_OUTPUT
            echo "workloads_ready=0" >> $GITHUB_OUTPUT
            echo "version_matched=$VERSION_MATCHED" >> $GITHUB_OUTPUT
            echo "deployment_id_matched=$DEPLOY_ID_MATCHED" >> $GITHUB_OUTPUT
            echo "sync_detection_method=timeout" >> $GITHUB_OUTPUT
            echo "status=Timeout" >> $GITHUB_OUTPUT
            echo "message=Timeout waiting for sync" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Find workloads and check state
          MATCHED_WORKLOADS=""
          WORKLOADS_FOUND=0
          ANY_VERSION_MATCH="false"
          ANY_DEPLOY_ID_MATCH="false"
          ANY_DEPLOY_ID_CHANGED="false"
          ANY_GENERATION_CHANGED="false"
          ALL_ROLLOUTS_COMPLETE="true"

          for TYPE in $(echo "$WORKLOAD_TYPES" | tr ',' ' '); do
            RESOURCES=$(kubectl get "$TYPE" -n "$NAMESPACE" -l "$SELECTOR" -o json 2>/dev/null || echo '{"items":[]}')
            COUNT=$(echo "$RESOURCES" | jq '.items | length')

            for i in $(seq 0 $((COUNT - 1))); do
              NAME=$(echo "$RESOURCES" | jq -r ".items[$i].metadata.name")
              CURRENT_VERSION=$(echo "$RESOURCES" | jq -r ".items[$i].metadata.labels[\"app.kubernetes.io/version\"] // \"\"")
              CURRENT_DEPLOY_ID=$(echo "$RESOURCES" | jq -r ".items[$i].metadata.annotations[\"deployment-id\"] // \"\"")
              CURRENT_GENERATION=$(echo "$RESOURCES" | jq -r ".items[$i].metadata.generation // \"0\"")
              OBSERVED_GENERATION=$(echo "$RESOURCES" | jq -r ".items[$i].status.observedGeneration // \"0\"")
              READY_REPLICAS=$(echo "$RESOURCES" | jq -r ".items[$i].status.readyReplicas // 0")
              DESIRED_REPLICAS=$(echo "$RESOURCES" | jq -r ".items[$i].spec.replicas // 1")

              KEY="${TYPE}/${NAME}"
              WORKLOADS_FOUND=$((WORKLOADS_FOUND + 1))

              # Check if deployment-id changed from initial
              INITIAL_ID="${INITIAL_DEPLOY_IDS[$KEY]:-}"
              if [ -n "$CURRENT_DEPLOY_ID" ] && [ "$CURRENT_DEPLOY_ID" != "$INITIAL_ID" ]; then
                ANY_DEPLOY_ID_CHANGED="true"
              fi

              # Check if generation changed from initial
              INITIAL_GEN="${INITIAL_GENERATIONS[$KEY]:-0}"
              if [ "$CURRENT_GENERATION" != "$INITIAL_GEN" ]; then
                ANY_GENERATION_CHANGED="true"
              fi

              # Check version match
              if [ -n "$EXPECTED_VERSION" ]; then
                if [ "$CURRENT_VERSION" == "$EXPECTED_VERSION" ]; then
                  ANY_VERSION_MATCH="true"
                fi
              fi

              # Check deployment-id match
              if [ -n "$EXPECTED_DEPLOY_ID" ]; then
                if [ "$CURRENT_DEPLOY_ID" == "$EXPECTED_DEPLOY_ID" ]; then
                  ANY_DEPLOY_ID_MATCH="true"
                fi
              fi

              # Check if rollout is complete (for fallback detection)
              if [ "$OBSERVED_GENERATION" != "$CURRENT_GENERATION" ] || [ "$READY_REPLICAS" != "$DESIRED_REPLICAS" ]; then
                ALL_ROLLOUTS_COMPLETE="false"
              fi

              MATCHED_WORKLOADS="${MATCHED_WORKLOADS}${KEY}|${CURRENT_VERSION}|${CURRENT_DEPLOY_ID}|${CURRENT_GENERATION}|${OBSERVED_GENERATION}|${READY_REPLICAS}/${DESIRED_REPLICAS}\n"
            done
          done

          # Determine if we should proceed based on strategy
          SHOULD_PROCEED="false"

          case "$DETECTION_STRATEGY" in
            "expected_deployment_id")
              if [ "$ANY_DEPLOY_ID_MATCH" == "true" ]; then
                SHOULD_PROCEED="true"
                DEPLOY_ID_MATCHED="true"
                SYNC_DETECTION_METHOD="expected_match"
                echo "  âœ… Deployment-id matched: $EXPECTED_DEPLOY_ID"
              fi
              ;;

            "expected_version")
              if [ "$ANY_VERSION_MATCH" == "true" ]; then
                # Version matches - but also need confirmation it's a new deployment
                if [ "$ANY_DEPLOY_ID_CHANGED" == "true" ] || [ "$ANY_GENERATION_CHANGED" == "true" ] || [ $INITIAL_WORKLOADS_FOUND -eq 0 ]; then
                  SHOULD_PROCEED="true"
                  VERSION_MATCHED="true"
                  SYNC_DETECTION_METHOD="expected_match"
                  echo "  âœ… Version matched: $EXPECTED_VERSION (with confirmed change)"
                fi
              fi
              ;;

            "deployment_id_change"|"deployment_id_change_fallback")
              if [ "$ANY_DEPLOY_ID_CHANGED" == "true" ]; then
                SHOULD_PROCEED="true"
                SYNC_DETECTION_METHOD="change_detected"
                echo "  âœ… Deployment-id changed from initial"
                [ -n "$EXPECTED_VERSION" ] && [ "$ANY_VERSION_MATCH" == "true" ] && VERSION_MATCHED="true"
              fi
              ;;

            "generation_change"|"generation_change_fallback")
              if [ "$ANY_GENERATION_CHANGED" == "true" ]; then
                SHOULD_PROCEED="true"
                SYNC_DETECTION_METHOD="change_detected"
                echo "  âœ… Generation changed from initial"
                [ -n "$EXPECTED_VERSION" ] && [ "$ANY_VERSION_MATCH" == "true" ] && VERSION_MATCHED="true"
              fi
              ;;
          esac

          # Fallback check: if no change detected after fallback_timeout, check if already synced
          if [ "$SHOULD_PROCEED" == "false" ] && [[ "$DETECTION_STRATEGY" == *"_fallback" ]] && [ "$FALLBACK_CHECK_DONE" == "false" ]; then
            if [ $ELAPSED -ge $FALLBACK_TIMEOUT_SECS ]; then
              FALLBACK_CHECK_DONE="true"
              echo ""
              echo "  â° Fallback timeout reached (${FALLBACK_TIMEOUT_SECS}s), checking if already synced..."

              if [ $WORKLOADS_FOUND -gt 0 ] && [ "$ALL_ROLLOUTS_COMPLETE" == "true" ]; then
                SHOULD_PROCEED="true"
                SYNC_DETECTION_METHOD="already_synced"
                echo "  âœ… All workloads appear ready - assuming sync already completed"
              else
                echo "  â³ Workloads not ready yet, continuing to wait..."
              fi
            fi
          fi

          # New workloads appeared (first deployment)
          if [ "$SHOULD_PROCEED" == "false" ] && [ $INITIAL_WORKLOADS_FOUND -eq 0 ] && [ $WORKLOADS_FOUND -gt 0 ]; then
            SHOULD_PROCEED="true"
            SYNC_DETECTION_METHOD="new_workloads"
            echo "  âœ… New workloads detected"
          fi

          if [ "$SHOULD_PROCEED" == "true" ]; then
            break
          fi

          # Log current state periodically (every 10 seconds)
          if [ $((ELAPSED - LAST_LOG_TIME)) -ge 10 ]; then
            LAST_LOG_TIME=$ELAPSED
            REMAINING=$((TIMEOUT_SECS - ELAPSED))
            echo "  [$ELAPSED/${TIMEOUT_SECS}s] Waiting... (found $WORKLOADS_FOUND workloads, ${REMAINING}s remaining)"
            if [ $WORKLOADS_FOUND -gt 0 ]; then
              echo -e "$MATCHED_WORKLOADS" | head -3 | while IFS='|' read -r key ver did gen obsgen replicas; do
                [ -z "$key" ] && continue
                echo "    $key: v=$ver did=$did gen=$gen/$obsgen replicas=$replicas"
              done
            fi
          fi

          sleep 3
        done

        if [ $WORKLOADS_FOUND -eq 0 ]; then
          echo "::warning::No workloads found matching selector: $SELECTOR"
          echo "workloads_found=0" >> $GITHUB_OUTPUT
          echo "workloads_ready=0" >> $GITHUB_OUTPUT
          echo "version_matched=$VERSION_MATCHED" >> $GITHUB_OUTPUT
          echo "deployment_id_matched=$DEPLOY_ID_MATCHED" >> $GITHUB_OUTPUT
          echo "sync_detection_method=no_workloads" >> $GITHUB_OUTPUT
          echo "status=Ready" >> $GITHUB_OUTPUT
          echo "message=No workloads found matching selector" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo ""
        echo "Found $WORKLOADS_FOUND workload(s):"
        echo -e "$MATCHED_WORKLOADS" | while IFS='|' read -r key ver did gen obsgen replicas; do
          [ -z "$key" ] && continue
          echo "  - $key (version: $ver, deployment-id: $did)"
        done

        # ============================================================
        # STEP 2: Wait for rollouts to complete
        # ============================================================
        echo ""
        echo "ðŸš€ Step 2: Waiting for rollouts to complete..."

        WORKLOADS_READY=0
        FAILED_WORKLOADS=""

        # Re-fetch workloads to get current list
        for TYPE in $(echo "$WORKLOAD_TYPES" | tr ',' ' '); do
          RESOURCES=$(kubectl get "$TYPE" -n "$NAMESPACE" -l "$SELECTOR" -o json 2>/dev/null || echo '{"items":[]}')
          COUNT=$(echo "$RESOURCES" | jq '.items | length')

          for i in $(seq 0 $((COUNT - 1))); do
            NAME=$(echo "$RESOURCES" | jq -r ".items[$i].metadata.name")
            KEY="${TYPE}/${NAME}"

            # Calculate remaining time
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))
            REMAINING=$((TIMEOUT_SECS - ELAPSED))

            if [ $REMAINING -le 0 ]; then
              echo "::error::Overall timeout exceeded"
              FAILED_WORKLOADS="${FAILED_WORKLOADS}${KEY} (timeout)\n"
              continue
            fi

            echo "  â³ Waiting for $KEY (timeout: ${REMAINING}s)..."

            if kubectl rollout status "$KEY" -n "$NAMESPACE" --timeout="${REMAINING}s" 2>&1; then
              echo "  âœ… $KEY is ready"
              WORKLOADS_READY=$((WORKLOADS_READY + 1))
            else
              echo "  âŒ $KEY failed or timed out"
              FAILED_WORKLOADS="${FAILED_WORKLOADS}${KEY}\n"
            fi
          done
        done

        # ============================================================
        # STEP 3: Report results
        # ============================================================
        echo ""
        echo "ðŸ“Š Results:"
        echo "  Workloads found: $WORKLOADS_FOUND"
        echo "  Workloads ready: $WORKLOADS_READY"
        echo "  Detection method: $SYNC_DETECTION_METHOD"
        [ -n "$EXPECTED_VERSION" ] && echo "  Version matched: $VERSION_MATCHED"
        [ -n "$EXPECTED_DEPLOY_ID" ] && echo "  Deployment-id matched: $DEPLOY_ID_MATCHED"

        echo "workloads_found=$WORKLOADS_FOUND" >> $GITHUB_OUTPUT
        echo "workloads_ready=$WORKLOADS_READY" >> $GITHUB_OUTPUT
        echo "version_matched=$VERSION_MATCHED" >> $GITHUB_OUTPUT
        echo "deployment_id_matched=$DEPLOY_ID_MATCHED" >> $GITHUB_OUTPUT
        echo "sync_detection_method=$SYNC_DETECTION_METHOD" >> $GITHUB_OUTPUT

        if [ "$WORKLOADS_READY" -eq "$WORKLOADS_FOUND" ]; then
          echo ""
          echo "âœ… All workloads are ready"
          echo "status=Ready" >> $GITHUB_OUTPUT
          echo "message=All $WORKLOADS_FOUND workloads are ready" >> $GITHUB_OUTPUT
        else
          echo ""
          echo "::error::Some workloads failed to become ready"
          echo -e "Failed workloads:\n$FAILED_WORKLOADS"
          echo "status=Failed" >> $GITHUB_OUTPUT
          echo "message=$WORKLOADS_READY of $WORKLOADS_FOUND workloads ready" >> $GITHUB_OUTPUT
          exit 1
        fi

    - name: Generate summary
      if: always()
      shell: bash
      run: |
        echo "## ðŸ”„ ArgoCD Sync Status" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Application:** ${{ inputs.app_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**Namespace:** ${{ inputs.namespace }}" >> $GITHUB_STEP_SUMMARY
        echo "**Selector:** ${{ inputs.selector || format('app.kubernetes.io/name={0}', inputs.app_name) }}" >> $GITHUB_STEP_SUMMARY
        echo "**Detection Method:** ${{ steps.wait.outputs.sync_detection_method }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        if [ -n "${{ inputs.expected_version }}" ] || [ -n "${{ inputs.expected_deployment_id }}" ]; then
          echo "### Expected Values" >> $GITHUB_STEP_SUMMARY
          [ -n "${{ inputs.expected_version }}" ] && echo "- **Version:** ${{ inputs.expected_version }} â†’ ${{ steps.wait.outputs.version_matched }}" >> $GITHUB_STEP_SUMMARY
          [ -n "${{ inputs.expected_deployment_id }}" ] && echo "- **Deployment ID:** ${{ inputs.expected_deployment_id }} â†’ ${{ steps.wait.outputs.deployment_id_matched }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
        fi

        echo "### Results" >> $GITHUB_STEP_SUMMARY
        echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| Workloads Found | ${{ steps.wait.outputs.workloads_found }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Workloads Ready | ${{ steps.wait.outputs.workloads_ready }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Status | ${{ steps.wait.outputs.status }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        if [ "${{ steps.wait.outputs.status }}" == "Ready" ]; then
          echo "âœ… All workloads synced and ready" >> $GITHUB_STEP_SUMMARY
        else
          echo "âŒ ${{ steps.wait.outputs.message }}" >> $GITHUB_STEP_SUMMARY
        fi
